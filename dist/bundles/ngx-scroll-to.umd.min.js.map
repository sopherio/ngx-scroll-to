{"version":3,"file":"ngx-scroll-to.umd.min.js","sources":["~/@nicky-lenaers/ngx-scroll-to/src/app/modules/scroll-to/statics/scroll-to-helpers.ts","~/@nicky-lenaers/ngx-scroll-to/src/app/modules/scroll-to/statics/scroll-to-animation.ts","~/@nicky-lenaers/ngx-scroll-to/src/app/modules/scroll-to/scroll-to.service.ts","~/@nicky-lenaers/ngx-scroll-to/src/app/modules/scroll-to/scroll-to.directive.ts","~/@nicky-lenaers/ngx-scroll-to/src/app/modules/scroll-to/scroll-to.module.ts"],"sourcesContent":["import { ElementRef } from '@angular/core';\n\nimport {\n  ScrollToAnimationEasing,\n  ScrollToAnimationEasingCollection\n} from '../models/scroll-to-easing.model';\nimport { ScrollToEvent } from '../models/scroll-to-event.model';\nimport {\n  ScrollToConfigOptions,\n  ScrollToDefaultConfigOptions\n} from '../models/scroll-to-config.model';\n/**\n * Default values for Component Input.\n */\nexport const DEFAULTS: ScrollToDefaultConfigOptions = {\n  target: null,\n  action: 'click',\n  duration: 650,\n  easing: 'easeInOutQuad',\n  offset: 0,\n  offsetMap: new Map()\n};\n/**\n * Easing Colleciton.\n */\nexport const EASING: ScrollToAnimationEasingCollection = {\n  easeInQuad: (time: number) => {\n    return time * time;\n  },\n  easeOutQuad: (time: number) => {\n    return time * (2 - time);\n  },\n  easeInOutQuad: (time: number) => {\n    return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;\n  },\n  easeInCubic: (time: number) => {\n    return time * time * time;\n  },\n  easeOutCubic: (time: number) => {\n    return (--time) * time * time + 1;\n  },\n  easeInOutCubic: (time: number) => {\n    return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n  },\n  easeInQuart: (time: number) => {\n    return time * time * time * time;\n  },\n  easeOutQuart: (time: number) => {\n    return 1 - (--time) * time * time * time;\n  },\n  easeInOutQuart: (time: number) => {\n    return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time;\n  },\n  easeInQuint: (time: number) => {\n    return time * time * time * time * time;\n  },\n  easeOutQuint: (time: number) => {\n    return 1 + (--time) * time * time * time * time;\n  },\n  easeInOutQuint: (time: number) => {\n    return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time;\n  },\n  easeOutElastic: (time: number) => {\n    return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;\n  }\n};\n/**\n * Set of allowed events as triggers\n * for the Animation to start.\n */\nexport const EVENTS: string[] = [\n  'click',\n  'mouseenter',\n  'mouseover',\n  'mousedown',\n  'mouseup',\n  'dblclick',\n  'contextmenu',\n  'wheel',\n  'mouseleave',\n  'mouseout'\n];\n/**\n * Strip hash (#) from value.\n * \n * @param {?} value \t\t\t\tThe given string value\n * @return {?} \t\t\t\t\tThe stripped string value\n */\nexport function stripHash(value: string): string {\n  return value.substring(0, 1) === '#' ? value.substring(1) : value;\n}\n/**\n * Test if a given value is a string.\n * \n * @param {?} value \t\t\t\t\tThe given value\n * @return {?} \t\t\t\t\t\tWhether the given value is a string\n */\nexport function isString(value: any): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n/**\n * Test if a given Element is the Window.\n * \n * @param {?} container \t\t\t\tThe given Element\n * @return {?} \t\t\t\t\t\tWhether the given Element is Window\n */\nexport function isWindow(container: any): container is Window {\n  return container === window;\n}\n/**\n * Test if a given value is of type ElementRef.\n * \n * @param {?} value \t\t\t\t\tThe given value\n * @return {?} Whether the given value is a number\n */\nexport function isElementRef(value: any): value is ElementRef {\n  return value instanceof ElementRef;\n}\n/**\n * Whether or not the given value is a Native Element.\n * \n * @param {?} value           The given value\n * @return {?} Whether or not the value is a Native Element\n */\nexport function isNativeElement(value: any): value is HTMLElement {\n  return value instanceof HTMLElement;\n}\n/**\n * Test if a given value is type number.\n * \n * @param {?} value \t\t\t\t\tThe given value\n * @return {?} \t\t\t\t\t\tWhether the given value is a number\n */\nexport function isNumber(value: any): value is number {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n}\n","import { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { Observable } from 'rxjs/Observable';\n\nimport { EASING } from '../statics/scroll-to-helpers';\nimport {\n  ScrollToConfigOptions,\n  ScrollToListenerTarget\n} from '../models/scroll-to-config.model';\nexport class ScrollToAnimation {\nprivate _tick: number;\nprivate _interval: any;\nprivate _timeLapsed: number;\nprivate _percentage: number;\nprivate _position: number;\nprivate _startPosition: number;\nprivate _distance: number;\nprivate _source$: ReplaySubject<number>;\nprivate _windowScrollTop: number;\n/**\n * @param {?} _container\n * @param {?} _listenerTarget\n * @param {?} _isWindow\n * @param {?} _to\n * @param {?} _options\n * @param {?} _isBrowser\n */\nconstructor(\nprivate _container: HTMLElement,\nprivate _listenerTarget: ScrollToListenerTarget,\nprivate readonly _isWindow: boolean,\nprivate readonly _to: number,\nprivate readonly _options: ScrollToConfigOptions,\nprivate _isBrowser: boolean\n  ) {\n    this._tick = 16;\n    this._interval = null;\n    this._timeLapsed = 0;\n\n    this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n    this._startPosition = this._isWindow ? this._windowScrollTop : this._container.scrollTop;\n\n    // Correction for Starting Position of nested HTML Elements\n    if (!this._isWindow) this._to = this._to - this._container.getBoundingClientRect().top + this._startPosition;\n\n    // Set Distance\n    const directionalDistance = this._startPosition - this._to;\n    this._distance = Math.abs(this._startPosition - this._to);\n\n    let offset = this._options.offset;\n\n    // Set offset from Offset Map\n    if (this._isBrowser) {\n\n      this._options\n        .offsetMap\n        .forEach((value, key) => offset = window.innerWidth > key ? value : offset);\n    }\n\n    this._distance += offset * (directionalDistance <= 0 ? 1 : -1);\n    this._source$ = new ReplaySubject();\n  }\n/**\n * Start the new Scroll Animation.\n * \n * @return {?} void\n */\npublic start(): Observable<any> {\n    clearInterval(this._interval);\n    this._interval = setInterval(this._loop, this._tick);\n    return this._source$.asObservable();\n  }\n/**\n * Recursively loop over the Scroll Animation.\n * \n * @return void\n */\nprivate _loop = (): void => {\n    this._timeLapsed += this._tick;\n    this._percentage = (this._timeLapsed / this._options.duration);\n    this._percentage = (this._percentage > 1) ? 1 : this._percentage;\n\n    // Position Update\n    this._position = this._startPosition +\n      ((this._startPosition - this._to < 0 ? 1 : -1) *\n      this._distance *\n      EASING[this._options.easing](this._percentage));\n\n    this._source$.next(this._position);\n    this._isWindow ? this._listenerTarget.scrollTo(0, Math.floor(this._position)) : this._container.scrollTop = Math.floor(this._position);\n    this.stop(false);\n  }\n/**\n * Stop the current Scroll Animation Loop.\n * \n * @param {?=} force \t\t\tForce to stop\n * @return {?}\n */\npublic stop(force: boolean = true): void {\n\n    const /** @type {?} */ curr_position = this._isWindow ? this._windowScrollTop : this._container.scrollTop;\n\n    if (force || this._position === (this._to + this._options.offset) || curr_position === (this._to + this._options.offset)) {\n      clearInterval(this._interval);\n      this._interval = null;\n      this._source$.complete();\n    }\n  }\n}\n\nfunction ScrollToAnimation_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollToAnimation.prototype._tick;\n/** @type {?} */\nScrollToAnimation.prototype._interval;\n/** @type {?} */\nScrollToAnimation.prototype._timeLapsed;\n/** @type {?} */\nScrollToAnimation.prototype._percentage;\n/** @type {?} */\nScrollToAnimation.prototype._position;\n/** @type {?} */\nScrollToAnimation.prototype._startPosition;\n/** @type {?} */\nScrollToAnimation.prototype._distance;\n/** @type {?} */\nScrollToAnimation.prototype._source$;\n/** @type {?} */\nScrollToAnimation.prototype._windowScrollTop;\n/**\n * Recursively loop over the Scroll Animation.\n * \n * \\@return void\n * @type {?}\n */\nScrollToAnimation.prototype._loop;\n/** @type {?} */\nScrollToAnimation.prototype._container;\n/** @type {?} */\nScrollToAnimation.prototype._listenerTarget;\n/** @type {?} */\nScrollToAnimation.prototype._isWindow;\n/** @type {?} */\nScrollToAnimation.prototype._to;\n/** @type {?} */\nScrollToAnimation.prototype._options;\n/** @type {?} */\nScrollToAnimation.prototype._isBrowser;\n}\n\n","import { Injectable, ElementRef, PLATFORM_ID, Inject } from '@angular/core';\nimport { DOCUMENT } from '@angular/platform-browser';\nimport { isPlatformBrowser } from '@angular/common';\n\nimport { Observable } from 'rxjs/Observable';\nimport'rxjs/add/observable/throw';\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\n\nimport { ScrollToAnimationEasing } from './models/scroll-to-easing.model';\nimport {\n  ScrollToConfigOptions,\n  ScrollToTarget,\n  ScrollToListenerTarget\n} from './models/scroll-to-config.model';\nimport { ScrollToAnimation } from './statics/scroll-to-animation';\nimport {\n  stripHash,\n  isString,\n  isNumber,\n  isElementRef,\n  isWindow,\n  DEFAULTS,\n  isNativeElement\n} from './statics/scroll-to-helpers';\n/**\n * The ScrollToService handles starting, interrupting\n * and ending the actual Scroll Animation. It provides\n * some utilities to find the proper HTML Element on a\n * given page to setup Event Listeners and calculate\n * distances for the Animation.\n */\nexport class ScrollToService {\n/**\n * The animation that provides the scrolling\n * to happen smoothly over time. Defining it here\n * allows for usage of e.g. `start` and `stop`\n * methods within this Angular Service.\n */\nprivate _animation: ScrollToAnimation;\n/**\n * Interruptive Events allow to scrolling animation\n * to be interrupted before it is finished. The list\n * of Interruptive Events represents those.\n */\nprivate _interruptiveEvents: string[];\n/**\n * Construct and setup required paratemeters.\n * \n * @param {?} _document         A Reference to the Document\n * @param {?} _platformId       Angular Platform ID\n */\nconstructor(\nprivate _document: any,\nprivate _platformId: any\n  ) {\n    this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];\n  }\n/**\n * Target an Element to scroll to. Notice that the `TimeOut` decorator\n * ensures the executing to take place in the next Angular lifecycle.\n * This allows for scrolling to elements that are e.g. initially hidden\n * by means of `*ngIf`, but ought to be scrolled to eventually.\n * \n * \\@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:\n * \t- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481\n * \n * @param {?} options         Configuration Object\n * @return {?} Observable\n */\npublic scrollTo(options: ScrollToConfigOptions): Observable<any> {\n\n    if (!isPlatformBrowser(this._platformId)) return new ReplaySubject().asObservable();\n\n    return this._start(options);\n  }\n/**\n * Start a new Animation.\n * \n * \\@todo Emit proper events from subscription\n * \n * @param {?} options         Configuration Object\n * @return {?} Observable\n */\nprivate _start(options: ScrollToConfigOptions): Observable<number> {\n\n    // Merge config with default values\n    const /** @type {?} */ mergedConfigOptions = {\n      ... /** @type {?} */((DEFAULTS as ScrollToConfigOptions)),\n      ...options\n    };\n\n    if (this._animation) this._animation.stop();\n\n    const /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);\n    if (!targetNode) return Observable.throw(new Error('Unable to get Target Element'));\n\n    const /** @type {?} */ container: HTMLElement = this._getContainer(mergedConfigOptions, targetNode);\n    if (!container) return Observable.throw(new Error('Unable to get Container Element'));\n\n    const /** @type {?} */ listenerTarget = this._getListenerTarget(container);\n    const /** @type {?} */ to: number = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;\n\n    // Create Animation\n    this._animation = new ScrollToAnimation(\n      container,\n      listenerTarget,\n      isWindow(listenerTarget),\n      to,\n      mergedConfigOptions,\n      isPlatformBrowser(this._platformId)\n    );\n    const /** @type {?} */ onInterrupt = () => this._animation.stop();\n    this._addInterruptiveEventListeners(listenerTarget, onInterrupt);\n\n    // Start Animation\n    const /** @type {?} */ animation$ = this._animation.start();\n    this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);\n\n    return animation$;\n  }\n/**\n * Subscribe to the events emitted from the Scrolling\n * Animation. Events might be used for e.g. unsubscribing\n * once finished.\n * \n * @param {?} animation$              The Animation Observable\n * @param {?} listenerTarget          The Listener Target for events\n * @param {?} onInterrupt             The handler for Interruptive Events\n * @return {?} Void\n */\nprivate _subscribeToAnimation(animation$: Observable<any>, listenerTarget, onInterrupt) {\n\n    const /** @type {?} */ subscription = animation$\n      .subscribe(\n        () => { },\n        () => { },\n        () => {\n          this._removeInterruptiveEventListeners(this._interruptiveEvents, listenerTarget, onInterrupt);\n          subscription.unsubscribe();\n        }\n      );\n  }\n/**\n * Get the container HTML Element in which\n * the scrolling should happen.\n * \n * @param {?} options         The Merged Configuration Object\n * @param {?} targetNode\n * @return {?}\n */\nprivate _getContainer(options: ScrollToConfigOptions, targetNode: HTMLElement): HTMLElement {\n\n    const /** @type {?} */ container: HTMLElement = options.container ?\n      this._getNode(options.container, true) :\n      this._getFirstScrollableParent(targetNode);\n\n    return container;\n  }\n/**\n * Add listeners for the Animation Interruptive Events\n * to the Listener Target.\n * \n * @param {?} listenerTarget    Target to attach the listener on\n * @param {?} handler           Handler for when the listener fires\n * @return {?} Void\n */\nprivate _addInterruptiveEventListeners(\n    listenerTarget: ScrollToListenerTarget,\n    handler: EventListenerOrEventListenerObject): void {\n\n    this._interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler));\n  }\n/**\n * Remove listeners for the Animation Interrupt Event from\n * the Listener Target. Specifying the correct handler prevents\n * memory leaks and makes the allocated memory available for\n * Garbage Collection.\n * \n * @param {?} events            List of Interruptive Events to remove\n * @param {?} listenerTarget    Target to attach the listener on\n * @param {?} handler           Handler for when the listener fires\n * @return {?} Void\n */\nprivate _removeInterruptiveEventListeners(\n    events: string[],\n    listenerTarget: ScrollToListenerTarget,\n    handler: EventListenerOrEventListenerObject): void {\n\n    events.forEach(event => listenerTarget.removeEventListener(event, handler));\n  }\n/**\n * Find the first scrollable parent Node of a given\n * Element. The DOM Tree gets searched upwards\n * to find this first scrollable parent. Parents might\n * be ignored by CSS styles applied to the HTML Element.\n * \n * @param {?} nativeElement     The Element to search the DOM Tree upwards from\n * @return {?} The first scrollable parent HTML Element\n */\nprivate _getFirstScrollableParent(nativeElement: HTMLElement): HTMLElement {\n\n    let /** @type {?} */ style: CSSStyleDeclaration = window.getComputedStyle(nativeElement);\n\n    const /** @type {?} */ overflowRegex: RegExp = /(auto|scroll)/;\n\n    if (style.position === 'fixed') return null;\n\n    for (let /** @type {?} */ parent = nativeElement; parent = parent.parentElement; null) {\n\n      style = window.getComputedStyle(parent);\n\n      if (style.position === 'absolute'\n        || style.overflow === 'hidden'\n        || style.overflowY === 'hidden') continue;\n\n      if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)\n        || parent.tagName === 'BODY') return parent;\n    }\n\n    return null;\n  }\n/**\n * Get the Target Node to scroll to.\n * \n * @param {?} id              The given ID of the node, either a string or\n *                        an element reference\n * @param {?=} allowBodyTag    Indicate whether or not the Document Body is\n *                        considered a valid Target Node\n * @return {?} The Target Node to scroll to\n */\nprivate _getNode(id: ScrollToTarget, allowBodyTag: boolean = false): HTMLElement {\n\n    let /** @type {?} */ targetNode: HTMLElement;\n\n    if (isString(id)) {\n\n      if (allowBodyTag && (id === 'body' || id === 'BODY')) {\n\n        targetNode = this._document.body;\n\n      } else {\n\n        targetNode = this._document.getElementById(stripHash(id));\n\n      }\n\n    } else if (isNumber(id)) {\n\n      targetNode = this._document.getElementById(String(id));\n\n    } else if (isElementRef(id)) {\n\n      targetNode = id.nativeElement;\n\n    } else if (isNativeElement(id)) {\n\n      targetNode = id;\n\n    }\n\n    return targetNode;\n\n  }\n/**\n * Retrieve the Listener target. This Listener Target is used\n * to attach Event Listeners on. In case of the target being\n * the Document Body, we need the actual `window` to listen\n * for events.\n * \n * @param {?} container           The HTML Container element\n * @return {?} The Listener Target to attach events on\n */\nprivate _getListenerTarget(container: HTMLElement): ScrollToListenerTarget {\n    return this._isDocumentBody(container) ? window : container;\n  }\n/**\n * Test if a given HTML Element is the Document Body.\n * \n * @param {?} element             The given HTML Element\n * @return {?} Whether or not the Element is the\n *                            Document Body Element\n */\nprivate _isDocumentBody(element: HTMLElement): element is HTMLBodyElement {\n    return element.tagName.toUpperCase() === 'BODY';\n  }\n\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [DOCUMENT, ] }, ]},\n{type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID, ] }, ]},\n];\n}\n\nfunction ScrollToService_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollToService.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollToService.ctorParameters;\n/**\n * The animation that provides the scrolling\n * to happen smoothly over time. Defining it here\n * allows for usage of e.g. `start` and `stop`\n * methods within this Angular Service.\n * @type {?}\n */\nScrollToService.prototype._animation;\n/**\n * Interruptive Events allow to scrolling animation\n * to be interrupted before it is finished. The list\n * of Interruptive Events represents those.\n * @type {?}\n */\nScrollToService.prototype._interruptiveEvents;\n/** @type {?} */\nScrollToService.prototype._document;\n/** @type {?} */\nScrollToService.prototype._platformId;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import {\n  Directive,\n  Input,\n  ElementRef,\n  Renderer2,\n  AfterViewInit\n} from '@angular/core';\n\nimport {\n  DEFAULTS,\n  EVENTS\n} from './statics/scroll-to-helpers';\nimport {\n  ScrollToConfigOptions,\n  ScrollToOffsetMap,\n  ScrollToTarget\n} from './models/scroll-to-config.model';\nimport {\n  ScrollToAnimationEasing\n} from './models/scroll-to-easing.model';\nimport { ScrollToEvent } from './models/scroll-to-event.model';\nimport { ScrollToService } from './scroll-to.service';\nexport class ScrollToDirective implements AfterViewInit {\npublic ngxScrollTo: ScrollToTarget = DEFAULTS.target;\npublic ngxScrollToEvent: ScrollToEvent = DEFAULTS.action;\npublic ngxScrollToDuration: number = DEFAULTS.duration;\npublic ngxScrollToEasing: ScrollToAnimationEasing = DEFAULTS.easing;\npublic ngxScrollToOffset: number = DEFAULTS.offset;\npublic ngxScrollToOffsetMap: ScrollToOffsetMap = DEFAULTS.offsetMap;\nprivate _options: ScrollToConfigOptions;\n/**\n * @param {?} _elementRef\n * @param {?} _scrollToService\n * @param {?} _renderer2\n */\nconstructor(\nprivate _elementRef: ElementRef,\nprivate _scrollToService: ScrollToService,\nprivate _renderer2: Renderer2) {\n\n  }\n/**\n * Angular Lifecycle Hook - After View Init\n * \n * \\@todo Implement Subscription for Events\n * \n * @return {?} void\n */\npublic ngAfterViewInit(): void {\n\n    // Test Event Support\n    if (EVENTS.indexOf(this.ngxScrollToEvent) === -1) throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);\n\n    // Listen for the trigger...\n    this._renderer2.listen(this._elementRef.nativeElement, this.ngxScrollToEvent,\n      (event: Event) => {\n\n        this._options = {\n          target: this.ngxScrollTo,\n          duration: this.ngxScrollToDuration,\n          easing: this.ngxScrollToEasing,\n          offset: this.ngxScrollToOffset,\n          offsetMap: this.ngxScrollToOffsetMap\n        };\n\n        this._scrollToService.scrollTo(this._options);\n      });\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  selector: '[ngx-scroll-to]'\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: ScrollToService, },\n{type: Renderer2, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'ngxScrollTo': [{ type: Input, args: ['ngx-scroll-to', ] },],\n'ngxScrollToEvent': [{ type: Input, args: ['ngx-scroll-to-event', ] },],\n'ngxScrollToDuration': [{ type: Input, args: ['ngx-scroll-to-duration', ] },],\n'ngxScrollToEasing': [{ type: Input, args: ['ngx-scroll-to-easing', ] },],\n'ngxScrollToOffset': [{ type: Input, args: ['ngx-scroll-to-offset', ] },],\n'ngxScrollToOffsetMap': [{ type: Input, args: ['ngx-scroll-to-offset-map', ] },],\n};\n}\n\nfunction ScrollToDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollToDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollToDirective.ctorParameters;\n/** @type {?} */\nScrollToDirective.propDecorators;\n/** @type {?} */\nScrollToDirective.prototype.ngxScrollTo;\n/** @type {?} */\nScrollToDirective.prototype.ngxScrollToEvent;\n/** @type {?} */\nScrollToDirective.prototype.ngxScrollToDuration;\n/** @type {?} */\nScrollToDirective.prototype.ngxScrollToEasing;\n/** @type {?} */\nScrollToDirective.prototype.ngxScrollToOffset;\n/** @type {?} */\nScrollToDirective.prototype.ngxScrollToOffsetMap;\n/** @type {?} */\nScrollToDirective.prototype._options;\n/** @type {?} */\nScrollToDirective.prototype._elementRef;\n/** @type {?} */\nScrollToDirective.prototype._scrollToService;\n/** @type {?} */\nScrollToDirective.prototype._renderer2;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { ScrollToDirective } from './scroll-to.directive';\nimport { ScrollToService } from './scroll-to.service';\nexport class ScrollToModule {\n/**\n * Guaranteed singletons for provided Services across App.\n * \n * @return {?} An Angular Module with Providers\n */\nstatic forRoot(): ModuleWithProviders {\n    return {\n      ngModule: ScrollToModule,\n      providers: [\n        ScrollToService\n      ]\n    };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [\n    ScrollToDirective\n  ],\n  exports: [\n    ScrollToDirective\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollToModule_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollToModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollToModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["DEFAULTS","target","action","duration","easing","offset","offsetMap","Map","EASING","easeInQuad","time","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeOutElastic","Math","pow","sin","PI","EVENTS","isWindow","container","window","ScrollToAnimation","_container","_listenerTarget","_isWindow","_to","_options","_isBrowser","_this","this","_loop","_timeLapsed","_tick","_percentage","_position","_startPosition","_distance","_source$","next","scrollTo","floor","scrollTop","stop","_interval","_windowScrollTop","pageYOffset","document","documentElement","body","getBoundingClientRect","top","directionalDistance","abs","forEach","value","key","innerWidth","ReplaySubject","prototype","start","clearInterval","setInterval","asObservable","force","curr_position","complete","ScrollToService","_document","_platformId","_interruptiveEvents","options","isPlatformBrowser","_start","mergedConfigOptions","Object","assign","_animation","targetNode","_getNode","Observable","throw","Error","_getContainer","listenerTarget","_getListenerTarget","to","offsetTop","onInterrupt","_addInterruptiveEventListeners","animation$","_subscribeToAnimation","subscription","subscribe","_removeInterruptiveEventListeners","unsubscribe","_getFirstScrollableParent","handler","event","addEventListener","events","removeEventListener","nativeElement","style","getComputedStyle","overflowRegex","position","parent","parentElement","overflow","overflowY","test","overflowX","tagName","id","allowBodyTag","String","getElementById","substring","isNaN","parseFloat","isFinite","ElementRef","HTMLElement","_isDocumentBody","element","toUpperCase","decorators","type","Injectable","ctorParameters","undefined","Inject","args","DOCUMENT","PLATFORM_ID","ScrollToDirective","_elementRef","_scrollToService","_renderer2","ngxScrollTo","ngxScrollToEvent","ngxScrollToDuration","ngxScrollToEasing","ngxScrollToOffset","ngxScrollToOffsetMap","ngAfterViewInit","indexOf","listen","Directive","selector","Renderer2","propDecorators","Input","ScrollToModule","forRoot","ngModule","providers","NgModule","declarations","exports"],"mappings":"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"}
